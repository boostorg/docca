#
# Copyright (c) 2019 Vinnie Falco (vinnie.falco@gmail.com)
# Copyright (c) 2021 Dmitry Arkhipov (grisumbras@gmail.com)
#
# Distributed under the Boost Software License, Version 1.0. (See accompanying
# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
#
# Official repository: https://github.com/cppalliance/json
#


import "class" : new ;
import feature ;
import doxygen ;
import modules ;
import option ;
import os ;
import param ;
import path ;
import print ;
import project ;
import property-set ;
import quickbook ;
import saxonhe ;
import sequence ;
import toolset ;
import type ;


.here  = [ path.make [ modules.binding $(__name__) ] ] ;
.here = $(.here:D) ;
.visualize = [ option.get docca-visualize : : "on" ] ;

.target-suffix = dir ;
if "on" = $(.visualize)
{
    .target-suffix = "$(.target-suffix)-vis" ;
}

rule reference ( target : sources * : requirements * : default-build *
    : usage-requirements * )
{
    param.handle-named-params
        sources requirements default-build usage-requirements ;

    local overrides = $(sources[1]) ;
    sources = $(sources[2-]) ;

    local project = [ project.current ] ;
    local target-dir = $(target:S=) ;
    target-dir = $(target-dir:B=_$(target-dir:B)-$(.target-suffix)) ;

    # Generate doxygen configuration file from sources
    sources = [ sequence.transform fix-source $(project) : $(sources) ] ;
    doxyfile $(target-dir)/sources.dox
        : $(sources)
        : $(requirements)
          <doxygen:param>GENERATE_HTML=NO
          <doxygen:param>GENERATE_XML=YES
          <doxygen:param>XML_OUTPUT=$(target-dir)
        : $(default-build)
        ;
    $(project).mark-target-as-explicit $(target-dir)/sources.dox ;

    #--------------------------------------------------------------------------
    #
    # Invoke Doxygen to process the header files and produce the XML
    # containing the description of the C++ declarations and extracted
    # Javadoc comments.
    doxygen-xml-multifile $(target-dir)/stamp
        : $(target-dir)/sources.dox
        : $(requirements)
        : $(default-build)
        ;
    $(project).mark-target-as-explicit $(target-dir)/stamp ;

    # Adopt as a target index.xml which was created as a side-effect
    make-explicit $(target-dir)/index.xml $(project)
        : $(target-dir)/stamp
        : @docca.null-action
        ;

    #--------------------------------------------------------------------------
    #
    # Copy visualization assets
    local vis-dir = $(.here)/xslt-visualizer ;
    local vis-assets ;
    for file in [ path.glob-tree $(.here)/xslt-visualizer/assets : *.* ]
    {
        local dir = [ path.relative $(file) $(vis-dir) ] ;
        dir = $(dir:D) ;
        vis-assets +=
          [ copy $(file) $(project) $(target-dir)/stage1_visualized/code-trace-enabled/$(dir) ]
          [ copy $(file) $(project) $(target-dir)/stage2_visualized/code-trace-enabled/$(dir) ]
          ;
    }
    alias $(target-dir)/vis-assets : $(vis-assets) ;
    $(project).mark-target-as-explicit $(target-dir)/vis-assets ;

    #--------------------------------------------------------------------------
    #
    # Copy the project-specific config XSLT
    copy $(overrides) $(project) $(target-dir) : : custom-overrides.xsl ;

    # Copy all the XSLT modules to the target directory.
    # Also, specify their dependencies.
    local src-dir = $(.here)/include/docca ;
    copy $(src-dir)/common.xsl                   $(project) $(target-dir) ;
    copy $(src-dir)/base-config.xsl              $(project) $(target-dir) ;
    copy $(src-dir)/assemble-quickbook.xsl       $(project) $(target-dir) ;
    copy $(src-dir)/debug-friendly-quickbook.xsl $(project) $(target-dir) ;

    copy $(src-dir)/base-extract-xml-pages.xsl $(project) $(target-dir)
        : common.xsl
        ;

    copy $(src-dir)/base-stage1.xsl $(project) $(target-dir)
        : common.xsl
        ;

    copy $(src-dir)/extract-xml-pages.xsl $(project) $(target-dir)
        : base-extract-xml-pages.xsl
          base-config.xsl
          custom-overrides.xsl
        ;

    copy $(src-dir)/stage1.xsl $(project) $(target-dir)
        : base-stage1.xsl
          base-config.xsl
          custom-overrides.xsl
        ;

    copy $(src-dir)/base-stage2.xsl $(project) $(target-dir)
        : common.xsl
        ;

    copy $(src-dir)/stage2.xsl $(project) $(target-dir)
        : base-stage2.xsl
          base-config.xsl
          custom-overrides.xsl
        ;

    # Copy visualization XSLT modules to the target directory.
    copy $(vis-dir)/xsl/lib/xml-to-string.xsl $(project) $(target-dir)/xsl/lib ;
    copy $(vis-dir)/xsl/guid.xsl $(project) $(target-dir)/xsl ;
    copy $(vis-dir)/xsl/generate-built-in-rules.xsl $(project) $(target-dir)/xsl ;
    copy $(vis-dir)/xsl/do-trace-enable.xsl $(project) $(target-dir)/xsl ;
    copy $(vis-dir)/xsl/to-string.xsl $(project) $(target-dir)/xsl ;
    copy $(vis-dir)/xsl/html-rule-tree.xsl $(project) $(target-dir)/xsl ;
    copy $(vis-dir)/xsl/run-trace.xsl $(project) $(target-dir)/xsl ;
    copy $(vis-dir)/xsl/trace-enable.xsl $(project) $(target-dir)/xsl
        : lib/xml-to-string.xsl
          guid.xsl
          generate-built-in-rules.xsl
          do-trace-enable.xsl
          to-string.xsl
          html-rule-tree.xsl
        ;

    if $(.visualize)
    {
        make-explicit $(target-dir)/stage1_visualized/code-trace-enabled/stage1.xsl
              $(project)
            : $(target-dir)/stage1.xsl
              $(target-dir)/xsl/trace-enable.xsl
            : @saxonhe.saxonhe
            ;

        make-explicit $(target-dir)/stage2_visualized/code-trace-enabled/stage2.xsl
              $(project)
            : $(target-dir)/stage2.xsl
              $(target-dir)/xsl/trace-enable.xsl
            : @saxonhe.saxonhe
            ;
    }

    # Generate stage2 parameters file
    make-explicit $(target-dir)/stage2-params.xml $(project)
        :
        : @docca.generate-stage2-params
        ;

    #-------------------------------------------------------------------------------
    #
    # Run index.xml through the first transformation stage
    # (assembling and splitting the XML into page-specific files).
    #
    make-explicit $(target-dir)/xml-pages.xml $(project)
        : $(target-dir)/index.xml
          $(target-dir)/extract-xml-pages.xsl
        : @saxonhe.saxonhe
        ;

    # Adopt as a target xml-pages directory which was created as a side-effect
    make-explicit $(target-dir)/xml-pages $(project)
        : $(target-dir)/xml-pages.xml
        : @docca.null-action
        ;

    if $(.visualize)
    {
        make-explicit $(target-dir)/stage1/results $(project)
            : $(target-dir)/xml-pages
              $(target-dir)/xsl/run-trace.xsl
            : @docca.saxonhe-dir
            : $(requirements)
              <flags>trace-enabled-stylesheet-uri=../stage1_visualized/code-trace-enabled/stage1.xsl
            ;

        make-explicit $(target-dir)/stage2/results $(project)
            : $(target-dir)/stage1/results
              $(target-dir)/xsl/run-trace.xsl
            : @docca.saxonhe-dir
            : $(requirements)
              <flags>trace-enabled-stylesheet-uri=../stage2_visualized/code-trace-enabled/stage2.xsl
              <flags>"?transform-params=doc(\"stage2-params.xml\")"
              <flags>principal-output-method=text
            ;

        make-explicit $(target-dir)/stage2/results/copied.stamp $(project)
            : $(target-dir)/xml-pages.xml
              $(target-dir)/debug-friendly-quickbook.xsl
            : @docca.saxonhe
            : $(requirements)
              <dependency>$(target-dir)/stage2/results
              <flags>input-dir=stage2_visualized/results
            ;
    }
    else
    {
        make-explicit $(target-dir)/stage1/results $(project)
            : $(target-dir)/xml-pages
              $(target-dir)/stage1-prepared.xsl
            : @docca.saxonhe-dir
            : $(requirements)
            ;

        make-explicit $(target-dir)/stage2/results $(project)
            : $(target-dir)/stage1/results
              $(target-dir)/stage2.xsl
            : @docca.saxonhe-dir
            : $(requirements)
            ;
    }

    generate $(target)
        : $(target-dir)/xml-pages.xml
          $(target-dir)/assemble-quickbook.xsl

          # TODO: make this input to the XSLT somehow
          #       rather than relying on it being hard-coded
          #       in the XSLT (which it is!)
          $(target-dir)/stage2/results
        : <generating-rule>@docca.make-qbk
          $(requirements)
        : $(default-build)
        : $(usage-requirements)
        ;
}


rule make-qbk ( project name : property-set : sources * )
{
        local action-name = saxonhe.saxonhe ;
        local relevant = [ toolset.relevant $(action-name) ] ;
        local action = [
              new action $(sources)
            : $(action-name)
            : [ $(property-set).relevant $(relevant) ]
            ] ;
        local target = [
              new file-target $(name) exact
            : [ type.type $(name) ]
            : $(project)
            : $(action)
            ] ;
        local path = [ path.root $(name) [ $(target).path ] ] ;
        return [ property-set.create <include>$(path:D) ] $(target) ;
}


local rule copy ( source project target-dir : dependencies * : new-name ? )
{
    local target ;
    if $(new-name)
    {
        target = $(new-name) ;
    }
    else
    {
        target = $(source:D=) ;
    }

    make-explicit $(target:TD=$(target-dir)) $(project)
        : $(source)
        : @common.copy
        : <dependency>$(target-dir)/$(dependencies)
        ;
}


local rule make-explicit ( target project : sources * : make-rule + : reqs *
    : ureqs * )
{
    make $(target) : $(sources) : $(make-rule) : $(reqs) : $(ureqs) ;
    $(project).mark-target-as-explicit $(target) ;

    return $(target) ;
}


local rule fix-source ( project path )
{
    # Unfortunately, rule doxygen.run was written with the assumption that
    # current project is located in the current directory (which is very likely
    # to not be the case). We have to convert paths into a form that is both
    # usable by doxygen and usable by b2 from the current project. This
    # effectively means absolute paths.
    #
    # NOTE: doxygen.run should really do this by itself.

    path = [ path.root $(path) [ $(project).location ] ] ;
    path = [ path.root $(path) [ path.pwd ] ] ;
    return $(path) ;
}


rule null-action
{
}


rule generate-stage2-params ( target : sources * : properties * )
{
    print.output $(target) ;
    print.text
          "<params>"
          "  <DEBUG>yes</DEBUG>"
          "</params>"
        : overwrite
        ;
}


.java_exe = [ modules.peek saxonhe : .java_exe ] ;
.saxonhe_jar = [ modules.peek saxonhe : .saxonhe_jar ] ;

toolset.flags docca.saxonhe-dir FLAGS : <flags> ;

actions saxonhe
{
    "$(.java_exe)" -jar "$(.saxonhe_jar)" -o:"$(<)" -s:"$(>[1])" -xsl:"$(>[2])" $(FLAGS)
}
if [ os.on-windows ]
{
    actions saxonhe-dir
    {
        if not exist "$(<)\\" mkdir "$(<)"
        "$(.java_exe)" -jar "$(.saxonhe_jar)" -o:"$(<)" -s:"$(>[1])" -xsl:"$(>[2])" $(FLAGS)
    }
}
else
{
    actions saxonhe-dir
    {
        mkdir -p "$(<)"
        "$(.java_exe)" -jar "$(.saxonhe_jar)" -o:"$(<)" -s:"$(>[1])" -xsl:"$(>[2])" $(FLAGS)
    }
}
